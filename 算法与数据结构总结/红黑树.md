我目前的印象中理解的红黑树：
    红黑树的插入，删除，查找 时间复杂度都是 O(logn)  非常高效
    为什么呢？ 红黑树的结构的特点：
    1.首先红黑树是由两种颜色的节点组成，他是一种基本平衡的二叉排序树，
    首先什么是二叉平衡树呢？
    二叉平衡树要求所有子树的高度差<=1,基本保障了左右子树的平衡，避免了那种高度差特别大，
    沦落为我们的链表，查找等时间复杂度和链表一样了 O（n）
    
    二叉树是接近平衡的平衡树，他并没有严格规定所有子树的高度差<=1，但是通过一些结构上的约束
    可以让左右子树的高度差不大于（n/2),n是高度

    2.那红黑树结构上有哪些特点呢：
    1）他这棵树是由红，黑两种颜色的节点组成的，
    2）他的每一条路径，路径即从根结点出发到叶子节点，每一条路径黑色节点的个数是相同的
    3）他的每一条路径上不会有两个或以上的连续的红色节点
    
重新学习定义：
什么是完全二叉树和满二叉树：
二叉排序树怎么插入,删除
平衡二叉树（AVL）（高度平衡的二叉查找树）
发明平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题
红黑树：
不严格的平衡二叉查找树
1.结构上的要求：
根节点是黑色的；

每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；

任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；

每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；

2.为什么要有红黑树：
AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了
所以，红黑树的插入、删除、查找各种操作性能都比较稳定
它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)。
但凡是用到动态插入、删除、查找数据的场景

3.红黑树的插入,查找和删除
1.插入：
红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点
魔法技巧：
如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。

如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。
2. 左右旋转和改变颜色
如果红黑树的平衡被打破，那一般会有下面三种情况。我们只需要根据每种情况的特点，不停地调整???
两个概念：
    叔叔：你的父节点的兄弟节点叫叔叔
    祖父：你的父节点的父亲几点叫祖父
    插入节点：插入a(插入元素的特点都是：插入元素在叶子处插入，且节点颜色都是红色的)
    当前关注节点
情况1：
    插入a,若他的叔叔节点是红色，则将叔叔和父亲节点变为黑色，祖父节点变成红色
情况2：
    插入a，若他的叔叔节点是黑色，a是父亲节点的右孩子，则关注点变成父亲节点，父亲节点进行左旋
情况3：
    插入a,若他的叔叔节点是黑色，a是父亲节点的左孩子，则关注点变成祖父节点，进行祖父节点的右旋，父亲节点和祖父节点的颜色进行交换
    


